
Unit and integration testing in UML is done done with nosetests. The expected
method of testing is by calling nosetests in the root UML directory. We are
generally reliant on nosetests' test discovery to find the tests we want run,
but at the same time there are some guidelines in place to encourage cleanly
organized code, and a couple of exceptions (discussed below) where organization
is strictly enforced.

First, a quick description of nosetests test discovery. Nosetests will recursively
search through everything in the called directory, looking for objects which
have names that look like tests according to a complicated regex. Some helpful
highlights with respect to how the regex works: if a name has a leading '_' it
is ignored. If a name starts with 'test' then it is test related. And if your
naming schema is lower_with_underscores and the name includes and underscore
separated 'test' then it will be test related. for a test function to be
run according to test discovery, it must have a test related name, and be in 
a module with a test related name. Alternatively, it may have a test related
name and be in a object with a test related name that is in a module with a
test related name.

The UML preferred test organization schema is to group all tests for a package
in a subpackage named tests. Roughly, if there is code in UML/foo/bar.py,
then we expect code that tests bar.py be in (one or more files named)
UML/foo/tests/baz.py, where the name baz, and the contents of the file baz.py
are named so that test discovery will find and run the tests. 

There are two cases where the organization requirements are more stringent,
making use of nosetests test organization at the object or package level
in order to do something otherwise impossible.

Firstly, UML.interfaces defines interfaces to packages which may not be
present on the host machine. Therefore tests of those interfaces, which
rely on those packages, must be conditionally disabled if the package
is not present. Therefore, if an interface is defined in UML/interfaces/foo.py
then any module in UML/interfaces/foo/tests which relies on the presence
of that interface must have foo as substring of its name. The common case
would be 'testfoo' or 'foo_test', but any substring relation will suffice.

Secondly, UML.data defines a class hierarchy of objects which share exactly
the same user facing API. It is inconvenient to have to define new tests
for each class, we want instead to write tests for each forward facing
function, and have it run once for each subclass. This is accomplished
by grouping all the tests into the objects DerivedBackend and
HighLevelBackend. Any subclass of UML.data.Base must have a corresponding
test object placed in UML.data.tests.testObjects and subclass from both
DerivedBackend and HighLevelBackend. During __init__ a call to
super(...).__init__ must be made with a string value to be used for the
retType parameter of UML.createData() defining which kind of object to 
be tested. Any further tests, for private helpers can also be placed in
that test object. We disallow all other ways of testing UML.data.Base
subclasses.
